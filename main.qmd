---
title: "EITF65 Study"

filters:
  - quizdown

author: 
  name: "Lukas Korotaj"
  email: "lu0026ko-s@student.lu.se"

theme: 
  - darkly
  - custom.scss

format:
  html:
    highlight-style: dracula
    code-appearance: true
    resource-path:
      - "figures"
    code-fold: true
    code-annotations: hover
    code-line-numbers: true
    toc: true
    toc-depth: 3
    toc-expand: true
    toc-location: body
    embed-resources: true
    self-contained-math: true

jupyter: python3


lang: en-US
---
# Info
Hello and welcome! I decided to write this page as a way to study for the upcoming exam. If you have any questions or suggestions, send them to my e-mail!

## General
This is my attempt at making an interactive exam-preparation page. It assumes you are familiar with Digital Design and have done the labs, as the focus will be more on repetition than learning from the beginning.

I am going to summarize the chapters I reference in the books myself. The choice of chapters was based on what I think is important in the subject, the training exam, the labs and some external sources. That being said, I don't know what the exam will be like, so it is quite possible that I miss some important detail.

Self-testing is important, so to aid with that I will add some quizzes at the end of each theory section.

## Stages
Let's get started! There will be four "stages". The stages have no deeper meaning, they are just there to divide the content a little. I reward myself with a cookie after each completed stage.

Each stage has *Concepts* and a *Quiz*.

In each stage I will be explaining the Concepts using the Relevant Sections. I won't be sourcing myself on every sentence.

The exercises are the odd-numbered exercises for which solutions exist in the [book companion](https://pages.hmc.edu/harris/ddca/ddcarv.html) page on Canvas. I will not go through every relevant exercise as that would be too much work.

::: {.callout-note collapse="true"}
### Stage 1: Core - Combinational Logic
* Concepts:
  * **Two's Complement and Overflow**
  * **Logic Minimization with K-Maps**
  * **Gray Codes**
  * **Timing** (Propagation delay and contamination delay, $t_{pd}$ and $t_{cd}$)
* Relevant Sections:
  * **1.4.6** Signed Binary Numbers
  * **2.7** Karnaugh Maps
  * **2.9** Timing
* Exercises:
  * **1.55, 1.61, 1.63**
  * **2.31, 2.33**
:::

::: {.callout-note collapse="true"}
### Stage 2: Sequential Logic & Timing of Sequential Logic
* Concepts:
  * **Latches & Flip-Flops**
  * **Static Timing Analysis**
  * **Clock Skew**
* Relevant Sections:
  * **3.2.2 - 3.2.3:** Latches and Flip-Flops
  * **3.5.1 - 3.5.3:** System Timing and Clock Skew
* Exercises:
  * **3.33**
  * **3.35, 3.37**
:::

::: {.callout-note collapse="true"}
### Stage 3: SystemVerilog
* Concepts:
  * **Always Blocks**
  * **Assignments**
  * **Reset Logic:** Asynchronous and Synchronous
  * **FSM Structure**
* Relevant Sections:
  * **4.2:** Combinational Logic
  * **4.4:** Sequential Logic
  * **4.5.4:** Blocking vs. Nonblocking Assignments.
  * **4.6:** FSMs in SystemVerilog.
* Exercises:
  * **4.15**
  * **4.27**
  * **4.33**
:::

::: {.callout-note collapse="true"}
### Stage 4: Standard Digital Modules
* Concepts:
  * **Finite State Machines (FSMs)**
  * **Arithmetic Circuits:** Half/Full Adders, ALUs.
* Relevant Sections:
  * **3.4.6:** FSM Review
  * **5.2.1 - 5.2.4:** Adders and ALUs
* Exercises:
  * **5.13**
  * **5.25**
:::

---

# Core - Combinational Logic

## Two's Complement
[*Two's Complement*](https://en.wikipedia.org/wiki/Two%27s_complement) is a way or representing *signed* binary numbers -- numbers that can also be negative. Two's complement numbers are negative when they have a 1 in the *Most Significant Bit* (MSB) position. Addition and subtraction works flawlessly with two's complement numbers. To do subtraction we can reverse the sign of one addend as $x-y$ is the same as $x+(-y)$. The sign of a two's complement is reversed by inverting all the bits and adding 1 to the *Least Significant Bit* (LSB) position. 

For example, to convert $2$ to $-2$, we would first write $2$ in binary, $0010$, then reverse the bits, $1101$, and add one to LSB, $1110$. So $-2 = 1110$.

The range of two's complement is $\left[ -2^{N-1},\ 2^{N-1} -1 \right]$, where $N$ is the number of bits.

Adding two N-bit positive or negative numbers may cause **overflow** if the result is greater than $2^{N-1} -1$ or lower than $2^{N-1}$. Overflow occurs if the two numbers being added have the same sign bit and the result has the opposite sign bit!

::: {.callout-note}
Overflow is when the result of an arithmetic operation exceeds the range that the specified number of bits can represent.
:::

To extend the number of bits a two's complement number has, copy the sign bit into the MSB position that number of times. So, if we want to extend 4-bits to 7-bits we do like this: $3 = 0011 = 0000011$ and $-3 = 1101 = 1111101$.

## K-Maps
::: {.callout-note}
K-Maps take some practice to get used to. Therefore, instead of writing a whole essay about K-maps, I will link a great resource [here](https://learnabout-electronics.org/Digital/dig24.php) that explains how to solve K-maps in detail. I will just summarize the rules as a reminder.
:::

[Karnaugh Maps](https://en.wikipedia.org/wiki/Karnaugh_map) (K-Maps) are a graphical method for simplifying Boolean equations. They work great for up to four variables. With more variables, multiple K-maps are required.

::: {.callout-tip}
### Another Boolean minimization rule
Remember that `~AB + A~B = A ^ B` and `~A~B + AB = ~(A ^ B)`!
:::

![Example of a K-map. Showing different examples of how to circle 1's.](./figures/k-map.png){fig-align="center" width=50%}

The rules for finding a minimized equation using a K-map are:

* User the fewest circles to cover all the 1's.
* All the squares in each circle must contain 1's (or *Don't Cares*, X).
* Each circle must span a rectangular block that is a power of 2.
* Each circle should be as large as possible.
* A circle may wrap around the edges.
* A square containing 1 may be circled multiple times if it allows for fewer circles.
* Additional rule for *Don't Cares*: They do not need to be circled if they are not helpful.

::: {.callout-warning}
Remember to label the axis in *Gray Code*!
:::

## Gray Code

[*Gray Code*](https://en.wikipedia.org/wiki/Gray_code) is an ordering of the binary system such that two successive values differ in only one bit. In practice, Gray code is used to reduce errors in different systems.

Guide to converting binary code to Gray code:

* The Most Significant Bit is the same.
* Go from left to right.
* Other bits of the Gray code are equal to the XOR of the bit of the same and previous index of the binary code.

![Binary code to Gray code](./figures/binary-to-gray.png){fig-align="center" width=50%}

To convert Gray code to binary:

* Copy the Most Significant Bit.
* The next binary number is the XOR of the previous binary number and the Gray code number at the same index.

![Gray code to binary code](./figures/gray-to-binary.png){fig-align="center" width=50%}




## Delay Basics
*Delay* can be defined as the time to change in response to an input change. In *combinational logic* there are two types of delays, *propagation delay* and *contamination delay*. The propagation delay $t_{pd}$ is the maximum time from when any input changes until the output reaches its final value. The contamination delay $t_{cd}$ is the minimum time until any output starts to change its value. Basically, $t_{pd}$ is the time from start until everything is over and $t_{cd}$ is the time from start until something happens.

![This figure shows a timing diagram with $t_{pd}$ and $t_{cd}$ visualized, for a buffer.](./figures/delays.jpg){fig-align="center" width=50%}

To find the propagation and contamination delay of a whole circuit we must consider the *critical path* and the *short path*. Simply put, the critical path is the longest path from any input to output, while the short path is the shortest path from any input to output.

![It's hard to see in the picture. But the Short Path is the gray one all the way down in the lower circuit.](./figures/paths.jpg){fig-align="center" width=50%}

Propagation delay in a circuit is sum of propagation delays of each element on the critical path. Contamination delay is the sum of the contamination delays of each element on the short path.

::: {.callout-tip collapse="true"}
### Quiz: Stage 1
```{quizdown}
# Two's Complement Conversion (single choice)

What is the 4-bit two's complement representation of the number **-3**?

> Remember: Invert the bits of $+3$ ($0011$) and add $1$ to the LSB.

1. [ ] 1010
1. [ ] 1100
1. [x] 1101
1. [ ] 1110

# Range of Two's Complement (single choice)

What is the range of values that can be represented by a **4-bit** two's complement number?

> The formula is $[ -2^{N-1}, 2^{N-1} -1 ]$. For $N=4$, this is $[-2^3, 2^3 - 1]$.

1. [ ] $[-7, 7]$
1. [x] $[-8, 7]$
1. [ ] $[-8, 8]$
1. [ ] $[0, 15]$

# Detecting Overflow (multiple choice)

When adding two $N$-bit two's complement numbers, which of the following conditions indicate an **overflow** has occurred?

> Overflow happens when the result "wraps around" into the sign bit incorrectly. This is physically detected when $C_{in} \neq C_{out}$ at the MSB.

- [ ] Adding a positive and a negative number results in a negative number.
- [x] Adding two positive numbers results in a negative number.
- [x] Adding two negative numbers results in a positive number.
- [ ] The Carry Out of the Most Significant Bit (MSB) is 1.

# K-Map Axis Labeling (sequence)

Order the row/column indices for a Karnaugh Map correctly.

> K-Map axes must be ordered in **Gray Code** sequence (only one bit changes at a time) to ensure that physically adjacent cells represent logically adjacent terms.

1. 00
2. 01
3. 11
4. 10

# Propagation vs. Contamination Delay (single choice)

Which delay metric represents the **minimum** time until any output starts to change its value after an input change?

> $t_{pd}$ is when *everything* is done (max time). $t_{cd}$ is when *something* starts to happen (min time).

1. [ ] Propagation Delay ($t_{pd}$)
1. [x] Contamination Delay ($t_{cd}$)
1. [ ] Setup Time ($t_{setup}$)
1. [ ] Hold Time ($t_{hold}$)

# Critical Path Analysis (single choice)

To calculate the **Propagation Delay** ($t_{pd}$) of an entire circuit, which path do you analyze?

> Propagation delay is the "worst-case" scenario, so you must find the longest path through the logic.

1. [x] The Critical Path (Longest path from input to output)
1. [ ] The Short Path (Shortest path from input to output)
1. [ ] The Average Path
1. [ ] The Clock Path
```
:::

# Sequential Logic & Timing of Sequential Logic
Before I get to the latches and flip-flops we first need to understand what *Sequential Logic* is. The crucial difference between combinational and sequential logic is that sequential logic has *memory*. The outputs of sequential logic depend both on the current and past inputs.

## D-Latches and Flip-Flops

A *D-latch* has two inputs, the *data* input, D, and the *clock*, CLK. When CLK is 1 the latch acts as a buffer, just passing through D. But when CLK is 0 the latch remembers its old value, and the output Q does not change. A *Flip-Flop* is simply two connected latches that solve a specific problem.

![A D-latch, the SR latch can be build using NOR or NAND gates. Depends on if the system is active high or low. This one is Active Low.](./figures/dlatch.png){fig-align="center" width=50%}

As latches are *level-triggered* they output values as long as the clock is high or low. This isn't ideal as it allows for races in a circuit. Flip-Flops are *edge-triggered* which means they output data only when the CLK is on *rising-edge*. The book highlights this: *A D flip-flop copies D to Q on the rising edge of the clock and remembers its state at all other times.*

## Timing

A flip-flop copies the input to the output on the rising edge of the clock. But what happens if the edge rises at the same time the input changes?

For sequential logic we use the clock-to-Q propagation delay $t_{pcq}$ and clock-to-Q contamination delay $t_{ccq}$. To understand the difference between $t_{pcq}$ and $t_{pd}$ think of the $t_{pcq}$ as the time needed for the flip-flop to output valid data (Q) after the rising clock edge hits it and the $t_{pd}$ as the time it takes for the signal to travel through logic gates between two flip-flops. The same goes for $t_{ccq}$ and $t_{cd}$.

For the outputs to be correct, the inputs need to be stable for some time, $t_{\text{setup}}$, before the rising edge of the clock. And must remain stable for some time after the rising edge of the clock, $t_{\text{hold}}$. 

$T_c$ is the *clock period*, the time between the rising edges of the clock. $f_c = 1/T_c$ is the *clock frequency*, measured in Hertz. The formula for finding the minimum clock period is as follows:

$$
T_c \geq t_{pcq} + t_{pd} + t_{\text{setup}}
$$
For tasks where *clock skew*, the variation in clock edges, is relevant, it is also required to add the $t_{\text{skew}}$ to the formula.

$$
T_c \geq t_{pcq} + t_{pd} + t_{\text{setup}} + t_{\text{skew}}
$$

$t_{\text{hold}}$ is usually irrelevant, the book ignores it but mentions the formula.

$$
t_{ccq} + t_{cd} \geq t_{\text{hold}} + t_{\text{skew}}
$$

::: {.callout-tip collapse="true"}
### Quiz: Stage 2
```{quizdown}
# Latch vs. Flip-Flop (single choice)

What is the fundamental difference between a D-Latch and a D-Flip-Flop?

> Latches are transparent while the clock is at a specific level (high or low). Flip-flops only update on an edge (rising or falling).

1. [ ] Latches have memory, Flip-Flops do not.
1. [ ] Latches update on the rising edge of the clock; Flip-Flops update when the clock is high.
1. [x] Latches are level-triggered; Flip-Flops are edge-triggered.
1. [ ] Flip-Flops are used for combinational logic; Latches are used for sequential logic.

# Setup Time Definition (single choice)

What does **Setup Time** ($t_{setup}$) represent?

> It is the "head start" the data needs before the clock snaps the picture.

1. [ ] The time the output must remain stable after the rising edge of the clock.
1. [x] The time the input must be stable *before* the rising edge of the clock.
1. [ ] The time it takes for the flip-flop to copy D to Q.
1. [ ] The minimum clock period allowed.

# Calculating Maximum Frequency (multiple choice)

Which of the following components are included when calculating the **minimum clock period** ($T_c$) required to avoid setup violations?

> $T_c \geq t_{pcq} + t_{pd} + t_{setup} + t_{skew}$. Note that $t_{hold}$ is NOT part of this equation (it relates to the short path, not the period).

- [x] Propagation Delay of Logic ($t_{pd}$)
- [x] Clock-to-Q Delay ($t_{pcq}$)
- [x] Setup Time ($t_{setup}$)
- [ ] Hold Time ($t_{hold}$)

# Clock Skew and Performance (single choice)

How does **Clock Skew** ($t_{skew}$) affect the maximum operating frequency of a circuit?

> Skew adds uncertainty. You have to wait longer ($T_c$ increases) to be safe, which means the frequency ($f = 1/T_c$) decreases.

1. [ ] It increases the maximum frequency (makes it faster).
1. [x] It decreases the maximum frequency (makes it slower).
1. [ ] It has no effect on frequency, only on hold time.
1. [ ] It improves the setup time margin.

# Hold Time Constraint (single choice)

Which inequality correctly represents the condition to prevent a **Hold Time Violation**?

> The fastest signal ($t_{ccq} + t_{cd}$) must be slower (arrive later) than the time the next flip-flop stops listening ($t_{hold}$).

1. [ ] $t_{pcq} + t_{pd} \geq t_{setup}$
1. [ ] $t_{ccq} + t_{cd} \leq t_{hold}$
1. [x] $t_{ccq} + t_{cd} \geq t_{hold}$
1. [ ] $t_{pd} + t_{setup} \geq t_{ccq}$

# Fixing Timing Violations (single choice)

If you have a **Setup Time Violation** (the circuit is too slow), what is the easiest way to fix it without changing the hardware?

> Setup violations depend on the clock period $T_c$. Increasing $T_c$ (slowing down the clock) gives the signal more time to arrive. Hold violations cannot be fixed this way because they are independent of the cycle time.

1. [ ] Decrease the clock period (increase frequency).
1. [x] Increase the clock period (decrease frequency).
1. [ ] Decrease the supply voltage.
1. [ ] You cannot fix it without changing the logic gates.
```
:::

# SystemVerilog
Since there is a lot of SystemVerilog syntax, and this is just repetition, I decided to add this interactive code block. You can hover over the circled numbers on the side to get the explanation of different parts of code. I assume you know the basics of SystemVerilog syntax.

This specific FSM outputs HIGH if the sequence of inputs is 1 and then 0.

```systemverilog
module sequence_detector (
    input  logic clk, reset,
    input  logic in,
    output logic out
);

    typedef enum logic [1:0] {S0, S1, S2} state_t; # <1>
    state_t current_state, next_state;             # <1>

    // 1. State Register (Sequential Logic)
    always_ff @(posedge clk, posedge reset) begin  # <2>
        if (reset)                                 # <3>
            current_state <= S0;                   # <3>
        else                                       # <4>
            current_state <= next_state;           # <4>
    end

    // 2. Next State Logic (Combinational Logic)
    always_comb begin                              # <5>
        case (current_state)                       # <6>
            S0: if (in) next_state = S1;           # <7>
                else    next_state = S0;           # <7>

            S1: if (in) next_state = S1;
                else    next_state = S2;           # <7>

            S2: if (in) next_state = S1;
                else    next_state = S0;

            default: next_state = S0;              # <8>
        endcase
    end

    // 3. Output Logic (Moore: Depends only on state)
    assign out = (current_state == S2);            # <9>

endmodule
```

1. Define the states using `enum`. This makes the code readable (using names like `S0`) while SystemVerilog handles the binary numbering (`00`, `01`, `10`) behind the scenes.
2. `always_ff` (ff stands for flip-flop) indicates **Sequential Logic**. It triggers on the rising edge of the clock (`posedge clk`) or reset.
3. **Asynchronous Reset:** If the reset signal goes high, the system immediately forces the state back to `S0`, ignoring the clock. The reset would be *synchronous* if the `posedge reset` wasn't there.
4. **State Update:** On every clock cycle (if not resetting), we update the `current_state` to whatever the `next_state` logic calculated. Note the use of **Non-Blocking Assignment** (`<=`) here, which is required for sequential logic.
5. `always_comb` indicates **Combinational Logic**. This block acts like a cloud of logic gates that instantly calculates the *next* move.
6. The `case` statement is the standard way to describe FSM transitions.
7. The logic: "If I am in `S0` and input `in` is 1, go to `S1`."
8. **Default case:** Good practice (and often required) to ensure that if the machine somehow reaches an undefined state, it resets safely rather than getting stuck.
9. **Moore Output:** The output is high *only* if we are in state `S2`. Since it does not depend on `in` (only `current_state`), it is a Moore machine.

::: {.callout-note}
The code block above has *module specifications*

```systemverilog
module module_name (
  input logic ...,
  output logic ...
);
...
endmodule
```
We did not need to do this in IceStudio, as it generates the module specifications for us. But in real SystemVerilog the specifications are required.

If you wish a bit more detailed syntax guide you can look at [this cheat sheet](https://www.cl.cam.ac.uk/teaching/1011/ECAD+Arch/files/SystemVerilogCheatSheet.pdf).
:::

![Graph of the FSM above](./figures/graph.svg)


Another code block showing additional syntax features of SystemVerilog.

```systemverilog

logic [1:0] raw_id;                  # <1>

// 1. Ternary Operator (Conditional Assignment)
assign valid = enable ? (|irq) : 1'b0; # <2>

// 2. Combinational Logic with casez
always_comb begin                    
    casez (irq)                      # <3>
        4'b1???: raw_id = 2'd3;      # <4>
        4'b01??: raw_id = 2'd2;      # <4>
        4'b001?: raw_id = 2'd1;      # <4>
        4'b0001: raw_id = 2'd0;      # <5>
        default: raw_id = 2'd0;
    endcase
end

assign id = valid ? raw_id : 2'b00;
```

1. **`logic` type:** In SystemVerilog, we use `logic` for almost everything. It replaces `reg` vs `wire` distinction from Verilog.
2. **`condition ? true_val : false_val`**: This is the **Ternary Operator**. It is a one-line if-else. Here, it says: "If `enable` is high, check if any interrupt bit is set; otherwise, output 0."
3. **`casez`**: A special version of `case` that allows "Don't Care" bits. It is essential for priority logic where you care about the highest bit but ignore the lower ones.
4. **`?` (Don't Care):** In a `casez` statement, `?` (or `z`) means "I don't care if this bit is 0 or 1."

5. **Specific Match:** You can mix precise bits with don't cares.

::: {.callout-note}
More about **reduction operators**: In the code example above you saw, `|irq` is a reduction operator. It basically performs the operator on all the bits in a vector, converting the answer to a single bit. In other words, if any bit in `irq` is HIGH the output is HIGH, as the operator performs OR on all bits.

|Operator       | Type  |
| ---           | ---   |
|&              | And   |
|~&             | Nand  |
|\|             | Or    |
|~\|            | Nor   |
|^              | Xor   |
|~^             | Xnor  |
:::

::: {.callout-tip collapse="true"}
### Quiz: Stage 3
```{quizdown}
# Synchronous vs. Asynchronous Reset (single choice)

How would you modify the following code to make the **Reset Synchronous** (so it waits for the clock edge)?

~~~systemverilog
always_ff @(posedge clk, posedge reset) begin
    if (reset) current_state <= S0;
    else       current_state <= next_state;
end
~~~

> Currently, `posedge reset` in the sensitivity list makes it Asynchronous.

1. [ ] Change `posedge reset` to `negedge reset`.
1. [ ] Remove `if (reset)` and just use `else`.
1. [x] Remove `posedge reset` from the sensitivity list `@(...)`.
1. [ ] Change `always_ff` to `always_comb`.

# Assignment Operators (single choice)

Why do we use the **Non-Blocking Assignment** (`<=`) inside the `always_ff` block?

> `always_ff` models sequential logic (flip-flops).

1. [ ] It is faster than blocking assignment.
1. [ ] It allows the reset to work asynchronously.
1. [x] It ensures all flip-flops update concurrently (at the same time) after the clock edge.
1. [ ] It is required for combinational logic.

# Reduction Operators (multiple choice)

If `logic [3:0] data = 4'b1010;`, what are the results of the following reduction operations?

> `|` is OR (is *any* bit 1?). `&` is AND (are *all* bits 1?).

- [x] `|data` evaluates to `1` (True).
- [ ] `&data` evaluates to `1` (True).
- [x] `&data` evaluates to `0` (False).
- [ ] `^data` (XOR) evaluates to `1` (Odd parity).

# Casez and Don't Cares (single choice)

In a `casez` statement, which of the following binary values will **match** the case item `4'b10??`?

> `?` means "ignore this bit". So we only care that bit 3 is `1` and bit 2 is `0`.

1. [ ] `0011`
1. [ ] `1100`
1. [x] `1001`
1. [ ] `0111`

# Moore vs. Mealy Code (single choice)

Which line of code confirms that the FSM example provided is a **Moore Machine**?

> Moore outputs depend *only* on the current state. Mealy outputs depend on the current state *and* the input.

1. [ ] `always_ff @(posedge clk, posedge reset)`
1. [ ] `if (in) next_state = S1;`
1. [x] `assign out = (current_state == S2);`
1. [ ] `typedef enum logic [1:0] {S0, S1, S2} state_t;`

# SystemVerilog Logic Type (single choice)

What is the advantage of using the `logic` data type in SystemVerilog?

> In older Verilog, you had to strictly choose between `reg` (for always blocks) and `wire` (for assign statements). `logic` handles both.

1. [x] It effectively replaces both `reg` and `wire`, preventing confusion.
1. [ ] It allows signals to be driven by multiple sources.
1. [ ] It automatically initializes values to 0.
1. [ ] It is only used for integer arithmetic.
```
:::

# Standard Digital Modules

## Finite State Machines
**Finite State Machines** are a great way to design sequential circuits from a specification. We designed multiple FSMs during the different labs. There are two types of FSMs, **Moore** and **Mealy**. Moore machines output depends only on the current state while Mealy depends on the state **and** the input. If you get to choose, a Moore machine is more stable and generally simpler, and a Mealy machine is more responsive and has fewer states.

The book has a section explaining FSMs, but you can also use [this](https://www.allaboutcircuits.com/textbook/digital/chpt-11/finite-state-machines/) resource if you want to read online.

To design an FSM follow these steps:

* Map the inputs and outputs.
* Sketch a state transition diagram.

![State Transition Diagram (Moore)](./figures/state-diagram-circuit.jpg){fig-align="center" width=50%}

* Write a state transition and output table.

![State transition and output table (Moore)](./figures/state-table.jpg){fig-align="center" width=50%}

![State transition and output table with a diagram (Mealy)](./figures/state-table-mealy.png){fig-align="center" width=50%}

* Select the state encodings. That means you convert the state names (S1, S0,...) to binary.

* Write Boolean equations for the next state and output logic. Perhaps using K-maps.

* Sketch the circuit.

* To implement an FSM in SystemVerilog, divide the FSM into three parts.
  * State register (`always_ff`).
  * Next state logic (combinational).
  * Output logic (combinational).

::: {.callout-note}
### SystemVerilog implementation of a Moore FSM (Example from the book).
```systemverilog
module patternMoore (
    input  logic clk,
    input  logic reset,
    input  logic a,
    output logic y
);
  typedef enum logic [1:0] {
    S0,
    S1,
    S2
  } statetype;
  statetype state, nextstate;
  // state register
  always_ff @(posedge clk, posedge reset)
    if (reset) state <= S0;
    else state <= nextstate;
  // next state logic
  always_comb
    case (state)
      S0:      if (a) nextstate = S0;
 else nextstate = S1;
      S1:      if (a) nextstate = S2;
 else nextstate = S1;
      S2:      if (a) nextstate = S0;
 else nextstate = S1;
      default: nextstate = S0;
    endcase
  // output logic
  assign y = (state == S2);
endmodule
```
:::

## Half Adder
To do addition we first build a *half adder*.

::: {.callout-note}
### A half-adder truth table.
|A      |B      | $C_{out}$     | S     |
| ---   | ---   | ---           | ---   |
|0      | 0     | 0             | 0     |
|0      | 1     | 0             | 1     |
|1      | 0     | 0             | 1     |
|1      | 1     | 1             | 0     |
:::

## Full Adder
A *full-adder* is a half-adder that accepts the $C_{out}$ as $C_{in}$. Where it acts as a term.

![Schematic of a full adder.](./figures/fullAdder-1.png){fig-align="center" width=50%}

## Ripple-Carry Adder
The adder we build in lab 2 is called a *Ripple-Carry Adder*. In a Ripple-Carry adder we connect N full adders where one adders $C_{in}$ is the other ones $C_{out}$. An N bit Ripple-Carry adder consists of N full adders.

The same works for subtraction! Remember that using two's complement one can subtract easily ($a - b = a + (-b)$).

::: {.callout-note}
### A Note on Overflow
If calculating unsigned numbers, if the Most Significant Bit has $C_{out} = 1$ then it indicates overflow. However, for signed number $C_{out} = 1$ does **not** indicate overflow. Remember that overflow in two's complement number happens when both addends have the same sign and the result has the opposite sign, `Overflow = C_inMSB ^ C_outMSB`
:::

## Arithmetic/Logical Unit
The *Arithmetic/Logical Unit* (ALU) combines a variety of mathematical and logical operations into a single unit. The ALU forms the heart of most computer systems.

::: {.callout-tip collapse="true"}
### Quiz: Stage 4

```{quizdown}
# Moore vs. Mealy Outputs (single choice)

What determines the output of a **Moore** Finite State Machine?

> A Moore machine is considered "safer" because its output is decoupled from the immediate changes in input signals.

1. [ ] The current state and the current inputs.
1. [x] Only the current state.
1. [ ] The previous state and the clock edge.
1. [ ] Only the current inputs.

# FSM Characteristics (single choice)

Which of the following advantages is associated with a **Mealy** machine compared to a Moore machine?

> Mealy machines look at inputs immediately, allowing them to react within the same clock cycle, often resulting in fewer required states.

1. [ ] It is generally more stable.
1. [ ] It is easier to implement in software.
1. [x] It is more responsive and often requires fewer states.
1. [ ] Its outputs are always synchronized with the clock.

# SystemVerilog FSM Structure (sequence)

When implementing an FSM in SystemVerilog, which order of logic blocks corresponds to the standard three-part design pattern?

> 1. Memory (Register) 2. Decision Making (Next State) 3. Translation (Output).

1. State Register (`always_ff`)
2. Next State Logic (`always_comb`)
3. Output Logic (`assign` or `always_comb`)

# Half Adder vs. Full Adder (single choice)

Why can't we build a multi-bit adder using **only** Half Adders?

> To chain adders together, each position needs to know if the previous position generated a carry.

1. [ ] Half Adders cannot perform binary addition.
1. [ ] Half Adders do not generate a Carry Out ($C_{out}$).
1. [x] Half Adders do not accept a Carry In ($C_{in}$).
1. [ ] Half Adders are too slow.

# Ripple-Carry Adder Connections (single choice)

In an N-bit Ripple-Carry Adder, how are the Full Adders connected to each other?

> The "Ripple" effect refers to the carry bit passing from the Least Significant Bit (LSB) up to the Most Significant Bit (MSB).

1. [ ] All Carry Inputs ($C_{in}$) are connected to the clock.
1. [x] The Carry Out ($C_{out}$) of one adder connects to the Carry In ($C_{in}$) of the next.
1. [ ] The Sum ($S$) of one adder connects to the Carry In ($C_{in}$) of the next.
1. [ ] They are not connected; they calculate in parallel.

# FSM State Encoding (single choice)

What does the step "Select the state encodings" refer to in the FSM design process?

> FSMs are abstract concepts with names like S0, S1. Hardware only understands 0s and 1s.

1. [ ] Drawing the state transition diagram.
1. [ ] Assigning inputs to specific pins on the FPGA.
1. [x] Converting abstract state names (e.g., S0, S1) into binary values.
1. [ ] Writing the SystemVerilog `always_ff` block.
```
:::

---

# Conclusion
This page is a small part of all the theory covered in the book. For example, I haven't talked at all about the RISC-V architecture, which was a big part of the labs. Again this is just meant to be repetition before the exam, not a whole book summary.

Another thing I want to mention. I did not include any logic gate symbol- and SystemVerilog syntax explanations. Like, for example, all the characters used to write Boolean logic. These are easy to find in the book and if I wanted to cover everything to that depth this page would be a lot bigger.

Hope you learned something or at least refreshed your knowledge reading this!
